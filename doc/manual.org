#+TITLE: The Document Compiler Manual
#+AUTHOR: Kevin Marschke <kmarshcke@ellem.ai>
Copyright \copy 2020 Ellem, Inc., all rights reserved.
* Introduction
This is a reference manual for the Document Compiler. For more
information and other documents, see [[https://ellem.ai/d-document-compiler][ellem.ai/d-document-compiler]].

Document compiler puts together text documnets by looking for specific
macros within the text documents themselves (such as .html, .txt, .js,
ect). Once compiled, the completed document is cached and can be
served over a variety of channels (http, fcgi, cli, ect).
** Example
The best way to learn is with examples. Observe the following files:

*header.html*
#+NAME: header.html
#+BEGIN_SRC html
<html>
<body>
<head><title>$(Title)</title></head>
#+END_SRC

*footer.html*
#+NAME: footer.html
#+BEGIN_SRC html
</body>
</html>
#+END_SRC

*myproc.go*
#+NAME: myproc.go
#+BEGIN_SRC go
// ...
func MyIP() string {
    return getRemoteIP()
}
// ...
#+END_SRC

And finally, *index.html*
#+NAME: index.html
#+BEGIN_SRC html
#prepend header.html
#append footer.html
#define $(MyName) Kevin
#define $(Title) Home Page

<p>Hello, my name is $(MyName).</p>
<p>My IP is $(myproc.MyIP)!</p>
#+END_SRC

Executing ~doccomp index.html~ will output the following:
#+NAME: output-example
#+BEGIN_SRC html
<html>
<body>
<head><title>Home Page</title></head>
<p>Hello, my name is Kevin.</p>
<p>My IP is 127.0.0.1!</p>
</body>
</html>
#+END_SRC
** Purpose
Here it is. Ellem has been working with HTTP/HTML for litterally
decades and we have never loved doing it until now. 

We've seen everything; php, node, react, webassembly, apache, nginx,
coldfusion, dart, typescript, asp.net, drupal, squarespace,
wordpress. Why have all these products and technologies been made?
What problem is so big that there needs to have an endless amount of
solutions to support it? The problem is simple:

*HTTP sucks.*

The entire planet has adopted a standard that was never in a million
years supposed to be as widley used as it is now. HTML was made in a
weekend by 1 man who had no advanced knowlege in computer
engineering. HTTP was made by a small team trying to solve a problem
they had between a team of 50 people. Javascript was made in 2 weeks
and is named after another language to trick people in to using
it. But now: we've chosen these crappy technologies to serve as the
backbone to the most important wealth of knowledge in the history of
the solar system.

Ellem plans to mend the damage caused by the Internet's choice of
protocol with Vorlage. People using Vorlage will be forced to do
everything very deliberately and explicitly, all while being forced to
provide comprehendsive documentation to every step.

*No more chaos. Vorlage demands order.*

* Components
There's four distinct components to the Document Compiler:
*[[Documents]]*, *[[Input]]*, *[[Variables]]*, *[[Macros]]*, and
*[[Processors]]*. Documents are simply files such as text files, HTML
files, ect. Input is what the user has given in regards to the
generation of the document. Variables are symbols found in the
document that will be replaced with arbitrary text when the document
is compiled.  Macros are used to append and prepend documents, as well
as define variables. Finally, Processors are used to integrate complex
formation of what is known as [[Processed]] variables.

Note that additional, more technical components such as caching, how
Documents are requested, and how documents are served will not be
covered in this manual. This manual is strictly for those wanting to
use the Document Compiler, not develop for it.

** Loading Process
 1. *Startup Phase*: Vorlage loads all processors and loads all
    supporting libraries. After this phase, Vorlage is ready to
    concurently handle multiple requests indefintely.
 2. *Requesting Phase*: A file path is requested by the user through
    Document Compiler. This requested path is known as the "root
    document". The user will also specify input at this point. Once
    the Request has been fully loaded, it then enters the Loading
    Phase.
 3. *Loading Phase*: Document Compiler loads the root
    document and does the following actions known as "docload":
    1. Vorlage then evaluates [[Macros]] found in the document in order of
       appearance.
    2. Vorlage attempts to open documents specified in the [[#append]] and
       [[#prepend]] macros that were evaluated in 1. These documents are
       known as "child documents"
    3. Each child document is then sent through docload (this inturn
       making docload a recursive process).
    Once docload is complete, the root document and child documents
    are sent to their converters in order to go from their [[Source
    Format]] to their [[Target Format]]. At this point we're ready to move
    to the Output Phase. Note that the Loading Phase can be skipped
    and/or shortend with the use of chaching.
 4. *Output Phase*: With the processors ready, request information
    parsed, docuemnt and child documents loaded into their Target
    Format, and all [[#define]] macros evaluated, the Output Phase can
    begin. A document in the Output Phase can be streamed to the user
    who had requested the document in the first place. This is the end
    of the life cycle for the document.
 5. *Shutdown Phase*: Vorlage unloads all the processors and deloads
    all supporting libraries. All connections and requests will be
    terminated.

* Documents
Documents are UTF-8 encoded files. The text is not canonicalized, so a
single accented code point is distinct from the same character
constructed from combining an accent and a letter; those are treated
as two code points.

All documents are considered to have *[[Source Formats]]* as well their
desired *[[Target Formats]]*. These source formats and target formats will
change from version to version. In regards to Document Compiler
v1.0.0, the supported formats are listed below as well as their file
extension (which will become important later).

A single Document can prepend and appened an unlimited number of other
Documents with the use of [[Macros]]. A Document can also define variables
(using [[#define]]) to be used within that document, or, by documents that
include it or included by it.
** Source Fomrats
 - [[https://html.spec.whatwg.org/multipage/][html]] (.html)
** Target Formats
 - [[https://html.spec.whatwg.org/multipage/][html]] (.html)
* Macros
Macros are actions to perform during the compolation of a
Document. The presense of Macros are completely removed from the
Document(s) after they are compiled. The identity of a Macro must
follow this syntax:

 1. Must be either at the very start of the Document or be directly
    after by another Macro,
 2. must start with =#= called a *Macro Prefix*,
 3. followed by a UTF-8 alpha string called the *Maco Name*
 4. followed by arbitrary text called *Arguments*... of which each one
    is preceeded by a space (char code =0x20=) and optionally wrapped
    in double quotation marks (char code =0x22=), and;
 5. will be ended with 1 newline (char code =0x10=).

Available Macros:

 - [[#define]]
 - [[#append]]
 - [[#prepend]]

** #define
This macro defines a [[Normal]] Variable. It has 2 arguments, the first
argument being the Normal Variable and the second being what it will
be defined as. Note that the first argument must be the entirety of
the Normal Variable and not just the Variable Name, this means the
=#define= will include the Variable Prefix =$(= and Variable
Suffix =)=. For example

#+BEGIN_SRC html
#define $(Name) Kevin

Hello, my name is $(Name).
#+END_SRC

Note that if =#define= attempts to define an previously defined
variable, the Document will not be compiled and will return an error.

** #append
Append includes a Document (the includee) that, when compiled, be
outputted /after/ the includer. The includee's Macros will
be processed the instant the #append is evaluated.

Note: [[Circular Dependancy]] is detected, the Document will not
compile and an error outputted.

** #prepend
Append includes a Document (the includee) that, when compiled, be
outputted /before/ the includer. The includee's Macros will
be processed the instant the #prepend is evaluated.

Note that if a [[Circular Dependancy]] is detected, the Document will not
compile and an error outputted.
* Variables
Inside of a Document, there exists Variables. During the Output Phase,
these variables are replaced with arbitrary text (or binary) regarded
as the variable's *Definition*. Variables come in 2 flavors: *[[Normal]]*
and *[[Processed]]*, the only difference is how these their Definitions
are written (one uses [[#define]], the other uses [[Processors]], more on this
later).

At the core of everything, a Variable is identified by a unique string
of text. This string of text must follow a particular syntax to be
valid. The syntax is as follows:

 1. A variable must begin with =$(= called a *Variable Prefix*,
 2. followed by UTF-8 alphanumaric string /unless/ it is a Processed
    Variable to which a dot (=.=) is also present somewhere in the
    middle. This is called the *Variable Name*, and;
 3. finally end with =)= called a *Variable Suffix*

Note: the Document Compiler will first attempt to locate Variable
Prefixes and Suffix pairs, only after that it will then determain the
validity of the variable name. If you've used an undefined and/or
misformatted Variable Name, then an Document Compiler will fail to
compile the Document and return an error.

Note: no Variable can exceed 32 characters (=MaxVariableLength=). Not
to be confused with the Variable's Definition, of which can be an
unlimited length.

Example: =$(MyName)=, is a Normal Variable, and =MyName= is the
Variable Name.

** Normal
Normal Variables are defined by using the [[#define]] macro, this define
macro can be in the root Document itself, or a Document that has been
either prepended or appended to that root Document. In any case, a
Normal Variable can be used in any document, parent or child, as
[[#define]] adds the Variable's definition to the context of the Request,
not to the root Document.

** Processed
Processed Variables are tangitably different from Normal variables
because their Variable Name has a dot (=.=) seperating the
later-discussed *[[Processor Name]]* and the name fimiluar with the
Processor called the *Processor-Variable Name*.

Example: =$(myproc.BlobPosts)= is a Processed variable,
=myproc.BlogPosts= is the Variable Name, =myproc= is the Processor
Name, and =BlobPosts= is the Processor-Variable Name.

Any given Processed Variable may require *[[Input]]* of which is loaded in
during the Request Phase. Thus, Processor Variables are a lot like
function call.

Once a Processed Variable has been fully loaded, meaning that the
poccessor was fully loaded, the variable was found, and the inputs are
a match, the processor will then be responsible for defining it. Note
that any errors that occour during definition will be logged and will
not stop the overall Request. Thus, Processed Variables have no
ability to hinder the Output Phase.

* Input
User input is only used for Processed Variables.

During the Loading Phase, when a processor is loaded, it will provide
Vorlage with a list of it's Processed Variables (herein "procinfo").

Each Processed Variable in procinfo will specify it's *Input*. Each
item in the input is known as a *Input Argument*. Each Input Argument
will have a name and description. Each Processed Variable must specify
a comprehendsive list of Input Arguments. When the Processed Variable
is defined during the Output Phase, Vorlage will only be provided the
Input Arguments it had listed in the procinfo. 

Example: If =$(mytranslator.german)= is detected inside the document,
the processor =mytranslator= will be loaded and that processor will
then demand that the =german= variable be supplied an Input with the
variable name of =english=. As you can see, =$(mytranslator.german)=
translates english to german. For a more applied exmaple, if we were
in the context of HTTP/HTML, the request
=www.mywebsite.com/germantranslator.proc.html?english=Hello= will
cause all instances of =$(mytanslator.german)= in
=germantranslator.proc.html= to be compiled to "Guten Tag".

#+BEGIN_COMMENT  I don't want to specify static/streamed in here. leave it impl-sepcficic

The values (ie. =hello=) are ignored by Vorlage and are simply passed
along to the processor. However; Values comes in two forms: *[[Static Argument values][Static]]*
[[Stream Argument values][]] and *[[Streamed Values]]*. The list of Input
Names for a given Processor Variable must be mutually exclusive
between Static and Streamed.

** Static Argument values
Static Values are simple, and should be used more or less 95% of the
time with Document Compiler. Static Values are given to the Processor
in entirety. The transloator above is an example of static values.

So you're probably wondering, "static values seems like everything
I'll ever need... what is this other type of value?", Let's move on.

** Streamed Argument Values
Streamed Values are complex in nature but very powerful. Streamed
values are NOT given to the Processor in entirety. The Processor is
instead given a file descriptor to which it can read from.

An example of when you should use Inputs with Streamed Value is file
uploads. For instance if you try to upload a 6GiB file and supply
it too the processor via a Static Value that would mean you'd need to
store the entire file in 6GiB of memory. Using a Streamed Value means
document compiler doesn't need to read the entire file.

There's a drawback with Streamed Values, and that's its inability to
be supplied more than once. Inputs using Streamed Values can only be
used once per Compiliation.

For instance, if =$(myconverter.ToPNG)= requires a =imageFile= Input
to be streamed, it will output the PNG conversion. But,
=$(myconverter.ToJPEG)= also requires a =imageFile= Input to be
streamed. Thus an error will occour if you try to include both
=$(myconverter.ToPNG)= and =$(myconverter.ToJPEG)= on the same page
because one will read the stream to its end and the other will be
given nothing but an empty stream.

Note that it is still possible to make that practicle example work,
but you'd have to add a better degree of backend engineering, such as
to replace the use of 2 Streamed Values with 1 Streamed Values and 2
other Processed Variables that will read from a file saved by Streamed
Value Input and output the conversions.


#+END_COMMENT
** Processor Input
During the Startup Phase, the procinfo supplied by each processor may
also request that the processor itself be given Input known as
*Processor Input*. During the Request Phase, each processor will be
given their respective Processor Input in the same form as if it was
being given to a Processor Variable.

This give the processors an opertunity to react to the request itself,
at this time the processor may demand that the overall request be
terminated or perform other actions that is proper to the protocol
that Vorlage is using. For example, a processor may want to set
cookies in an HTTP request. And of course this cannot be done during
the Output Phase as HTTP disallows setting cookies during the
outputting of the page.

* Processors
Processors provide you with the ability to perform arbitrary code
execution during points in the Request Phase and the Output
Phase. Under normal (non-erroneous) operation, a given Processor has
only one duty and that is to define [[Processed][variables that will be dependant
on that given processor]]. Thus that when the Document is compiled,
Processors can dynamiaclly populate these Processed Variables acrossed
page request.

Concluseivly, Processors allow a Vorlage to interact with an
unlimited amount of applications such as databases, authentication,
logging, auditing, searching, ect.

To create a Processor, you must first compile a *[[Processor File]]* and
then have it in the relvant *[[Library Path]]* so that Vorlage can load it
during the Startup Phase. Once that is done, the Processor can then
define Processor-Variable Names in which will be defined by that
Processor onces the Variables are requested.

Note, Processors are technical in nature. An increase depenedency on
them will lead to difficult-to-edit documents that defeats entire
purpose of Vorlage. 

** Processor File
A processor file contains native code that contains the proper
exports. Support for types of processor files will varity as Vorlage
gains maturaty. As of now, the following supported file types (and
formats) are supported:

 - ELF 64-bit LSB shared object (see [[http://tldp.org/HOWTO/Program-Library-HOWTO/shared-libraries.html][here]]) (=libmyproc.so=)
 - current ar archive with ELF 64-bit LSB relocatable objects
   (=myproc.a=)

*Building a processor*
In this example, we'll be building a processor that was written in
=main.c=:

=<doccomp/doccom.h>=
#+BEGIN_SRC c
#include "sys/types.h"

typedef struct {
// TODO
} dc_proc_info_t;

typedef struct {
// TODO
} dc_proc_definer_t;

typedef u_int64_t dc_rid;
#+END_SRC

=<doccomp/processor.h>=
#+BEGIN_SRC
#include "doccomp.h"

// do not touch.
int dcp_version = 1;

// if you're making a processor, you must define these:
dc_proc_info_t dcp_info;
dc_proc_definer_t dcp_define(dc_rid);
#+END_SRC

Now you can choose to write your processor using only
=<doccomp/processor.h>= making it universal, but you have the opition
to make a *domainTODO:FINDBUZZWORD-specific* processor. To which you
can include /one/ of the following header files and use their
repsective functions during each call. Each request's rid (=dc_rid=)
will be used with these implements to gather further
domainTODO-specific information and functionaility. If you include
these headers, you must link against the subsequent library as well.

| domainTODO:BUZZWORD | header             | library              | description                |
|---------------------+--------------------+----------------------+----------------------------|
| =http=              | =<doccomp/http.h>= | =doccomp/libhttp.so= | enabled for http           |
| =cli=               | =<doccomp/cli.h>=  | =doccomp/libcli.so=  | enabled for cli/bash       |
| =pdf=               | =<doccomp/pdf.h>=  | =doccomp/libpdf.so=  | enabled for pdf generation |

*** TODO is there really no way for them to include more than one? should that be a good idea?
It would make sense because =http= processors should always output
html. Don't want it trying to output pdf binary.

I mean if you don't include any of them, your processor can still be
linked by all implmenets. It encourages people not to get too needy



todo: remove all the other stuff in this section that does not reflect
of my desicion in the above C code... I make that my finaly descision.

*all compiler implements must have*

All implements (ie doccomp/http, doccomp/pdf, doccomp/cli) must have:
#+BEGIN_SRC c

#+END_SRC


and to build it we need to link the proper libraries, in this example,
we need to use the doccomp http library. Note that sense this
processor links against doccomp-http, it cannot run without it. Thus
this processor would not work in the command line.

#+BEGIN_SRC bash
~$ gcc -c -Wall -Werror -fpic myproc.c
~$ gcc -shared -o libmyproc.so myproc.o -ldoccomp -ldoccomp-http
~$ cp libmyproc.so /usr/local/doccomp-processors/
#+END_SRC
** Processor Name
A Processor Name is valid if and only if that name is alphanumaric
lowercase. The Processor Name should be a short word simular to a
package name. For example, =abc=, =123=, =abc123= are all valid
Processor Names and =AbC=, =?dD=, =f f= are not. The Processor Name
will be retireved by Document Compiler when scanning through the
Processor [[Storage]].


* Further Elaboration on Technical Details
** Circular Dependancies
A Circluar Dependancy is an error that occours when a Document
(/Document A/) includes another Document (/Document B/) in which
includes the includer document (/Document A/). This includes a
Document trying to inlcude itself. An example is shown below.

*Parent.html*
#+BEGIN_SRC html
#append Child.html

...
#+END_SRC



*Child.html*
#+BEGIN_SRC html
#append GrandChild.html

...
#+END_SRC


*GrandChild.html*
#+BEGIN_SRC html
#append Parent.html

...
#+END_SRC

You see that? =Parent.html= includes =Child.html= which includes
=GrandChild.html= which /then/ include =Parent.html=. Thus,
=Parent.html= is indirectly including itself, this is a circular
dependancy and will cause an error.




** Library Path
Processor Files must be placed somewhere in the filesystem. Finding
these files behaves a lot like system libraries in that they're found
by transversion enviroment paths (such as =LD_LIBRARY_PATH=). As
Document Compiler starts up, it will scan through what is known as
*Library Directories* to prepre the use of relevant Processor
Files. There can be 0, 1, or many Library Directories. But regardless
of how many, all of them are stored in what is the call Document
Compiler's *Library Path*. This Library Path is a string containing a
list of Library Directories delimited by a colon.

For example, =/usr/lib/doccomp:~/.doccomp:.= means that when Document
Compiler tries to find a Processor named =foo= it will search for it
in =/usr/lib/doccomp=, =~/.doccomp=, =.= (the working directory). The
first match is what is used.

It should be noted that the Document Compiler's Library Path is NOT
stored in the envrioment. It is stored in the [[Configuration]].
