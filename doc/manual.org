#+TITLE: The Document Compiler Manual
#+AUTHOR: Kevin Marschke <kmarshcke@ellem.ai>
Copyright \copy 2020 Ellem, Inc., all rights reserved.
* Introduction
This is a reference manual for the Document Compiler. For more
information and other documents, see [[https://ellem.ai/d-document-compiler][ellem.ai/d-document-compiler]].

Document compiler puts together text documnets by looking for specific
macros within the text documents themselves (such as .html, .txt, .js,
ect). Once compiled, the completed document is cached and can be
served over a variety of channels (http, fcgi, cli, ect).
** Example
The best way to learn is with examples. Observe the following files:

*header.html*
#+NAME: header.html
#+BEGIN_SRC html
<html>
<body>
<head><title>$(Title)</title></head>
#+END_SRC

*footer.html*
#+NAME: footer.html
#+BEGIN_SRC html
</body>
</html>
#+END_SRC

*myproc.go*
#+NAME: myproc.go
#+BEGIN_SRC go
// ...
func MyIP() string {
    return getRemoteIP()
}
// ...
#+END_SRC

And finally, *index.html*
#+NAME: index.html
#+BEGIN_SRC html
#prepend header.html
#append footer.html
#define $(MyName) Kevin
#define $(Title) Home Page

<p>Hello, my name is $(MyName).</p>
<p>My IP is $(myproc.MyIP)!</p>
#+END_SRC

Executing ~doccomp index.html~ will output the following:
#+NAME: output-example
#+BEGIN_SRC html
<html>
<body>
<head><title>Home Page</title></head>
<p>Hello, my name is Kevin.</p>
<p>My IP is 127.0.0.1!</p>
</body>
</html>
#+END_SRC
** Purpose
Here it is. Ellem has been working with HTTP/HTML for litterally
decades and we have never loved doing it until now. 

We've seen everything; php, node, react, webassembly, apache, nginx,
coldfusion, dart, typescript, asp.net, drupal, squarespace,
wordpress. Why have all these products and technologies been made?
What problem is so big that there needs to have an endless amount of
solutions to support it? The problem is simple:

*HTTP sucks*.

The entire planet has adopted a standard that was never in a million
years supposed to be as widley used as it is now. HTML was made in a
weekend by 1 man who had no advanced knowlege in computer
engineering. HTTP was made by a small team trying to solve a problem
they had between a team of 50 people. Javascript was made in 2 weeks
and is named after another language to trick people in to using it.

But now: The electrons that are used to process HTML, HTTP, and JS

* Components
There's four distinct components to the Document Compiler:
*[[Documents]]*, *[[Variables]]*, *[[Macros]]*, and *[[Processors]]*. Documents are
simply files such as text files, HTML files, ect. Macros are used to
append and prepend documents, as well as define variables. Variables
are symbols found in the document that will be replaced with arbitrary
text when the document is compiled. Finally, Processors are used to
integrate complex formation of what is known as [[Processed]] variables.

Note that additional, more technical components such as caching, how
Documents are requested, and how documents are served will not be
covered in this manual. This manual is strictly for those wanting to
use the Document Compiler, not develop for it.

** Loading Process
 1. First a file path is requested by the user through Document
    Compiler known as the "Root Document",
 2. Document Compiler loads the file found at that path,
 3. the Document Compiler then evalutes all available [[#define]] Macros,
    adding it to the Root Document,
 4. then evaluates all available [[#append]] and [[#prepend]] Macros in order
    of apperance, for each file path evaluated, steps 2-4 are repeated
    for that file path
 5. all (recursively) included documents includeing the Root document
    will be searched for the presence of Variables,
 6. all [[Normal]] Variables will be replaced with their respective
    definitions,
 7. [[Processors]] will then define all [[Process][Procces Variables]], and;
 8. finally The entiretly of the document is outputted.

* Documents
Documents are UTF-8 encoded files. The text is not canonicalized, so a
single accented code point is distinct from the same character
constructed from combining an accent and a letter; those are treated
as two code points.

All documents are considered to have *[[Input Formats]]* as well their
desired *[[Target Formats]]*. These formats are arbitrary, however, only a
certain amount of formats are supported by Document Compiler. These
input formats and target formats will change from version to
version. In regards to Document Compiler v1.0.0, the supported formats
are listed below as well as their file extension (which will become
important later).
** Input Fomrats
 - [[https://html.spec.whatwg.org/multipage/][html]] (.html)
 - [[https://orgmode.org/][org-mode]] (.org)
 - [[http://haml.info/][haml]] (.haml)
 - [[https://daringfireball.net/projects/markdown/syntax][markdown]] (.md)
** Target Formats
 - [[https://html.spec.whatwg.org/multipage/][html]] (.html)

** Converters
* Variables
Inside of a Document, there exists Variables. Once the document is
compiled, these variables are replaced with arbitrary text regarded as
the variable's *Definition*. Variables come in 2 flavors: *[[Normal]]* and
*[[Processed]]*, both of them are eventually replaced with their
respective Definitions, the only difference is how these their
Definitions are defined.

At the core of everything, a variable is identified by a unique string
of text. However, this string of text must follow a particular syntax
to be valid. The syntax is as follows:

 1. A variable must begin with =$(= called a *Variable Prefix*,
 2. followed by UTF-8 alphanumaric string /unless/ it is a
    Processed-type to which a dot (=.=) is also present called a
    *Variable Name*, and;
 3. finally end with =)= called a *Variable Suffix*

Note that the Document Compiler will first attempt to locate Variable
Prefixes and Suffix pairs, only after that it will then determain the
validity of the variable name. This means if you've used an undefined
and/or misformatted Variable Name, then an Document Compiler will fail
to compile the Document and return an error.

Note that no Variable can exceed 32 characters (=MaxVariableLength=).

** Normal
Normal Variables are defined by using the [[#define]] macro, this define
macro can be in the requested Document itself, or a Document that has
been either prepended or appended to that requested Document.

For example, =$(MyName)=, is a Normal Variable, and =MyName= is the
Variable Name.

** Processed
Processed Variables are tangitably different from Normal variables
because their Variable Name has a dot (=.=) seperating the
later-discussed *[[Processor Name]]* and the name fimiluar with the the
Processor called the *Processor-Variable Name*.

For example, =$(myproc.BlobPosts)= is a Processed variable, =myproc=
is the Processor Name, and =BlobPosts= is the Processor-Variable Name.

Each Processed Variables requires a Name and an optional
*[[Input]]*. Input is a lot like the arguments of a function, it's simply
a list of input names. All arguments of the input are assumed to be a
raw byte stream... which can easily be interpeted as a string most of
the time but also can be interpreted as other types such as ints or
floats in other cases.

Once a Processed Variable has been fully loaded, meaning that the
poccessor was fully loaded, the variable was found, and the inputs are
a match, the processor will then be responsible for defining it. Note
that any errors that occour during definition will be logged and will
not stop the overall request.

** Input
TODO: I'm thinking about remvoing input in favor of just supplying all
of the input to all the procvars. Because otherwise the use of
"required fields" will leave the page half-processed.

User input is only used for Processed Variables. Each Processed
Variable can define what Input it requires to function properly. The
Processed Variable will not be defined if the Document Compiler was
not given adequent input, and will result in an error which will be
blamed on the user.

TODO: as of now the software passes ALL INPUT to the processor, not
just the matching input... Not sure if this is right or not. On one
hand, input can be treaed like envrioment variables (where everything
should be avaialbe). On the other hand, Input can be treaed as
function arguments working only with the data that you asked
for... hmmm...

For example, if =$(mytranslator.german)= is detected inside the
document, the processor =mytranslator= will be loaded and that
processor will then demand that the =german= variable be supplied an
Input with the variable name of =english=. As you can see,
=$(mytranslator.german)= translates english to german. For a more
applied exmaple, if we were in the context of HTTP/HTML, the request
=www.mywebsite.com/germantranslator.proc.html?english=Hello= will cause
all instances of =$(mytanslator.german)= in
=germantranslator.proc.html= to be compiled to "Guten Tag".

The Inputs' Names (ie. =english=) are used to detect if all demanded
Input for a particular Processed Variable are satisfied. The values
(ie. =hello=) is ignored by the document compiler and are simply
passed along to the processor. However; Values comes in two forms:
*[[Static Values]]* and *[[Streamed Values]]*. The list of Input Names for a
given Processor Variable must be mutually exclusive between Static and
Streamed.

*** Static Values
Static Values are simple, and should be used more or less 95% of the
time with Document Compiler. Static Values are given to the Processor
in entirety. The transloator above is an example of static values.

So you're probably wondering, "static values seems like everything
I'll ever need... what is this other type of value?", Let's move on.

*** Streamed Values
Streamed Values are complex in nature but very powerful. Streamed
values are NOT given to the Processor in entirety. The Processor is
instead given a file descriptor to which it can read from.

An example of when you should use Inputs with Streamed Value is file
uploads. For instance if you try to upload a 6GiB file and supply
it too the processor via a Static Value that would mean you'd need to
store the entire file in 6GiB of memory. Using a Streamed Value means
document compiler doesn't need to read the entire file.

There's a drawback with Streamed Values, and that's its inability to
be supplied more than once. Inputs using Streamed Values can only be
used once per Compiliation.

For instance, if =$(myconverter.ToPNG)= requires a =imageFile= Input
to be streamed, it will output the PNG conversion. But,
=$(myconverter.ToJPEG)= also requires a =imageFile= Input to be
streamed. Thus an error will occour if you try to include both
=$(myconverter.ToPNG)= and =$(myconverter.ToJPEG)= on the same page
because one will read the stream to its end and the other will be
given nothing but an empty stream.

Note that it is still possible to make that practicle example work,
but you'd have to add a better degree of backend engineering, such as
to replace the use of 2 Streamed Values with 1 Streamed Values and 2
other Processed Variables that will read from a file saved by Streamed
Value Input and output the conversions.

* Macros
Macros are actions to perform during the compolation of a
Document. The variety of avaialbe Macros is limited by design. The
presense of Macros are completely removed from the Document(s) after
they are compiled. The identity of a Macro must follow this syntax:

 1. Must be either at the very start of the Document or be directly
    after by another Macro,
 2. must start with =#= called a *Macro Prefix*,
 3. followed by a UTF-8 alpha string called the *Maco Name*
 4. followed by arbitrary text called *Arguments*... of which each one
    is preceeded by a space (char code =0x20=) and optionally wrapped
    in double quotation marks (char code =0x22=), and;
 5. will be ended with 1 newline (char code =0x10=).

As mentioned before, there's a very limited amount of avaialbe Macros:

 - [[#define]]
 - [[#append]]
 - [[#prepend]]

** #define
This macro defines a [[Normal]] Variable. It has 2 arguments, the first
argument being the Normal Variable and the second being what it will
be defined as. Note that the first argument must be the entirety of
the Normal Variable and not just the Variable Name, this means the
=#define= will include the Variable Prefix =$(= and Variable
Suffix =)=. For example

#+BEGIN_SRC html
#define $(Name) Kevin

Hello, my name is $(Name)
#+END_SRC

Note that if =#define= attempts to define an previously defined
variable, the Document will not be compiled and will return an error.

** #append
Append includes a Document (the includee) that, when compiled, be
outputted /after/ the includer. The includee's Macros will
be processed the instant the #append is evaluated.

Note that if a [[Circular Dependancy]] is detected, the Document will not
compile and an error outputted.

** #prepend
Append includes a Document (the includee) that, when compiled, be
outputted /before/ the includer. The includee's Macros will
be processed the instant the #prepend is evaluated.

Note that if a [[Circular Dependancy]] is detected, the Document will not
compile and an error outputted.

* Processors

Processors provide you with the ability to perform arbitrary code
execution when a Document is requested. Under normal (non-erroneous)
operation, a given Processor has only one duty and that is to define
[[Processed][variables that will be dependant on that given processor]]. Thus that
when the Document is compiled, Processors can dynamiaclly populate
these Processed Variables acrossed page request. Concluseivly,
Processors allow a Document to interact with an unlimited amount of
applications such as databases, authentication, logging, auditing,
searching, ect.

To add a Processor to your Document, Document Compiler must detect the
relevant *[[Processor File]]* in the relvant *[[Library Path]]*. Once that is
done, the Processor can then define Processor-Variable Names in which
will be defined by that Processor onces the Variables are requested.

Note, Processors are technical in nature. An increase depenedency on
them will lead to difficult-to-edit documents that defeats entire
purpose of Document Compiler.

** Processor Name
A Processor Name is valid if and only if that name is alphanumaric
lowercase. The Processor Name should be a short word simular to a
package name. For example, =abc=, =123=, =abc123= are all valid
Processor Names and =AbC=, =?dD=, =f f= are not. The Processor Name
will be retireved by Document Compiler when scanning through the
Processor [[Storage]].

** Processor File
A processor file contains native code that contains the proper
exports. Support for types of processor files will varity as Document
Compile gains maturaty. As of now, the following supported file types
(and formats) are supported with 'myproc' as the given processor name.

 - libmyproc.so - ELF 64-bit LSB shared object (see [[http://tldp.org/HOWTO/Program-Library-HOWTO/shared-libraries.html][here]])
 - myproc.a - current ar archive with ELF 64-bit LSB relocatable
   objects
 - myproc.go.a - go pluging made using ~go build -buildmode=plugin~

*Required exports for myproc.a and libmyproc.so*
#+BEGIN_SRC c
//TODO
#+END_SRC

** Library Path
Processor Files must be placed somewhere in the filesystem. Finding
these files behaves a lot like system libraries in that they're found
by transversion enviroment paths (such as =LD_LIBRARY_PATH=). As
Document Compiler starts up, it will scan through what is known as
*Library Directories* to prepre the use of relevant Processor
Files. There can be 0, 1, or many Library Directories. But regardless
of how many, all of them are stored in what is the call Document
Compiler's *Library Path*. This Library Path is a string containing a
list of Library Directories delimited by a colon.

For example, =/usr/lib/doccomp:~/.doccomp:.= means that when Document
Compiler tries to find a Processor named =foo= it will search for it
in =/usr/lib/doccomp=, =~/.doccomp=, =.= (the working directory). The
first match is what is used.

It should be noted that the Document Compiler's Library Path is NOT
stored in the envrioment. It is stored in the [[Configuration]].

* Comparison to CGI, FastCGI, NodeJs, PHP, Java/C#
 - CGI runs the component per request.
 - FCGI has a single componenet running constantly. But cannot include
   additional compoenents without re-compiliation
 - NodeJS and PHP loads most of the componenet constantly. But keeps
   the remaining parts of the componenet running JIT. Does not require
   compiliation.
 - Java/C# componenets is much like NodeJS and PHP execpt the JIT is
   more effiecnet, using byte code.
 - DocComp is like FCGI, but loads additional components without
   re-compiliation.
 



* TODO Technical Elaboration 
** Configuration
** Circular Dependancies
A Circluar Dependancy is an error that occours when a Document
(/Document A/) includes another Document (/Document B/) in which
includes the includer document (/Document A/). This includes a
Document trying to inlcude itself. An example is shown below.

*Parent.html*
#+BEGIN_SRC html
#append Child.html

...
#+END_SRC



*Child.html*
#+BEGIN_SRC html
#append GrandChild.html

...
#+END_SRC


*GrandChild.html*
#+BEGIN_SRC html
#append Parent.html

...
#+END_SRC

You see that? =Parent.html= includes =Child.html= which includes
=GrandChild.html= which /then/ include =Parent.html=. Thus,
=Parent.html= is indirectly including itself, this is a circular
dependancy and will cause an error.




